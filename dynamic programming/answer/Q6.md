前回の問題においても、アルルがマス i にたどり着く直前の行動は M 通りありました。今回も同様になっています。

さて、次のような配列を定義しましょう。

dp[i] ← アルルがマス i にたどり着くことが可能かどうか (True / False)

仮にアルルがマス i にたどりつくことが可能であるならば、アルルがマス i にたどり着く直前の行動は次のいずれかであると考えられます。

    マス i−D0​ にたどりついたあと、サイコロで D0​ の目を出して、マス i に至る
    マス i−D1​ にたどりついたあと、サイコロで D1​ の目を出して、マス i に至る
    ...
    マス i−DM−1​ にたどりついたあと、サイコロで DM−1​ の目を出して、マス i に至る

これらの M 通りの場合が実現されるためには、次のことが必要十分条件となります。

ある j=0,1,…,M−1 が存在して、

    i−Dj​≥0 であること
    マス i−Dj​ にたどりつくことが可能であること (dp[i - D[j]] が True であること)

を満たすこと

逆にこの条件が満たされないならば、dp[i] = False となります。 以上を踏まえて、下のコード例のように、dp[1], dp[2], ..., dp[N] を順に決定していくことができます。

計算量は O(NM) となります。
動的計画法とは

ここまで、動的計画法と称した問題を 6 問解いてきました。このあたりで、「動的計画法とは何か」を整理してみましょう。ここまで問題を解いてきた方ならば、次の教科書を納得感をもって読めるものと思います。

動的計画法ってなに？　(結論)
解答例
C++ での解答例

#include <iostream>

#include <vector>

using namespace std;



int main() {

   // 入力

   int N, M;

   cin >> N >> M;

   vector<int> D(M);

   for (int i = 0; i < M; ++i) cin >> D[i];



   // 動的計画法の舞台となる配列

   vector<bool> dp(N + 1, false);



   // マス 0 にははじめから到達している

   dp[0] = true;



   // 順に計算していく

   for (int i = 1; i <= N; ++i) {

       for (int j = 0; j < M; ++j) {

           if (i - D[j] >= 0 && dp[i - D[j]]) {

               dp[i] = true;

           }

       }

   }



   // 出力

   cout << (dp[N] ? "Yes" : "No") << endl;

}

Python3 での解答例

# 入力

N, M = map(int, input().split())

D = list(map(int, input().split()))



# 動的計画法の舞台となる配列

dp = [False] * (N + 1)



# マス 0 にははじめから到達している

dp[0] = True



# 順に計算していく

for i in range(1, N + 1):

    for j in range(M):

        if i - D[j] >= 0 and dp[i - D[j]]:

            dp[i] = True



# 出力

print('Yes' if dp[N] else 'No')