この問題は、動的計画法 1-2 を拡張したものとなっています。動的計画法 1-2 では、アルルのとれる行動は 2 通りでした。それが今回は M 通りとなっています。

解法は本質的にはほとんど変わりません。動的計画法 1-2 では、アルルが各マス i=1,2,…,N−1 にたどり着く時刻を次のように求めました。

// 順に計算していく

for (int i = 2; i < N; ++i) {

    T[i] = min(T[i-1] + A[i], T[i-2] + A[i] * 2

}

(C++)

# 順に計算していく

for i in range(2, N):

    T[i] = min(T[i-1] + A[i], T[i-2] + A[i] * 2)

(Python3)

今回は、これを下のコードのように変更しましょう。T[i] の値を求めるのに、T[i-1], T[i-2], ..., T[i-M] の値をそれぞれ活用するのです。

// 順に計算していく

for (int i = 1; i < N; ++i) {

    for (int j = 1; j <= M; ++j) {

        if (i-j >= 0) {

            T[i] = min(T[i], T[i-j] + A[i] * j);

        }

    }

}

(C++)

# 順に計算していく

for i in range(1, N):

    for j in range(1, M+1):

        if i-j >= 0: 

            T[i] = min(T[i], T[i-j] + A[i] * j) 

(Python3)

T[i] = min(T[i], T[i-j] + A[i] * j) というように処理していくことで、T[i] には最終的には T[i-1] + A[i], T[i-2] + A[i] * 2, ..., T[i-M] + A[i] * M の最小値が格納されるようになります。

ここで、次の点には注意しましょう。

    T[i] はあらかじめ無限大を表す値 (下の解答例では変数 INF) に初期化しておきましょう
    添字 i-j が負にならないように、確認するようにしましょう

解答例
C++ での解答例

#include <iostream>

#include <vector>

using namespace std;



// 無限大を表す値 (1000000 にしておく)

const int INF = 1000000;



int main() {

	// 入力

	int N, M;

	cin >> N >> M;

	vector<int> A(N);

	for (int i = 0; i < N; ++i) cin >> A[i];



	// 計算の舞台となる配列を宣言

	vector<int> T(N, INF); 



	// 初期値を定める

	T[0] = 0;



	// 順に計算していく

	for (int i = 1; i < N; ++i) {

        for (int j = 1; j <= M; ++j) {

            if (i-j >= 0) {

                T[i] = min(T[i], T[i-j] + A[i] * j);

            }

        }

    }

    cout << T[N-1] << endl;

}

Python3 での解答例

# 無限大を表す値 (1000000 にしておく)

INF = 1000000



# 入力

N, M = map(int, input().split())

A = list(map(int, input().split()))



# 計算の舞台となる配列を宣言

T = [INF] * N



# 初期値を定める

T[0] = 0



# 順に計算していく

for i in range(1, N):

    for j in range(1, M+1):

        if i-j >= 0:

            T[i] = min(T[i], T[i-j] + A[i] * j)

print(T[-1])