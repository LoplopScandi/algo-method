いよいよ二次元の動的計画法をやっていきましょう！

今回は難しく考えずに、問題文の言われたとおりに実装すればよいでしょう。下の解答例のように実装できます。

ただし「左上や右上のマスを足すときに配列の外に出るものは考えない」といった処理を忘れないようにしましょう。
番兵法

左上のマスを足すときに配列の外に出るものを除外するのはやや面倒かもしれません。そのような煩雑さを防ぐ方法として、配列を余分に確保するという番兵法も活用してもよいでしょう。

今回の問題でいえば、6×6 の配列を用意してあげます。
解答例
C++ での解答例

#include <bits/stdc++.h>

using namespace std;



int main() {

    // 4 × 4 の配列を用意する

    // 配列全体を 0 に初期化しておく

    vector<vector<int>> A(4, vector<int>(4, 0));



    // 0 行目 (0-indexed だと最上段は 0 行目) の入力を受け取る

    for (int i = 0; i < 4; ++i) cin >> A[0][i];



    // 1, 2, 3 行目を順に計算していく

    for (int i = 1; i < 4; ++i) {

        for (int j = 0; j < 4; ++j) {

            // 真上を足す

            A[i][j] += A[i-1][j];



            // 左上を足す

            if (j - 1 >= 0) A[i][j] += A[i-1][j-1];



            // 右上を足す

            if (j + 1 < 4) A[i][j] += A[i-1][j+1];

        }

    }

    cout << A[3][3] << endl;

}

Python3 での解答例

# 4 × 4 の配列を用意する

# 配列全体を 0 に初期化しておく

A = [[0] * 4 for _ in range(4)]



# 0 行目 (0-indexed だと最上段は 0 行目) の入力を受け取る

A[0] = list(map(int, input().split()))



# 1, 2, 3 行目を順に計算していく

for i in range(1, 4):

    for j in range(4):

        # 真上を足す

        A[i][j] += A[i-1][j]



        # 左上を足す

        if j-1 >= 0:

            A[i][j] += A[i-1][j-1]



        # 右上を足す

        if j+1 < 4:

            A[i][j] += A[i-1][j+1]



print(A[3][3])